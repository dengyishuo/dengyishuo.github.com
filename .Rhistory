}
symbols
}
alignSymbols(c(symb1, symb2))  # 对齐两只股票的时间戳
# 定义金融工具
currency("USD")  # 基础货币为美元
stock(symb1, currency="USD", multiplier=1)  # 定义股票 1 的属性
stock(symb2, currency="USD", multiplier=1)  # 定义股票 2 的属性
# 初始化投资组合、账户和订单
initPortf(name=portfolio1.st, c(symb1,symb2))  # 创建包含两只股票的组合
initAcct(account.st, portfolios=portfolio1.st, initEq=initEq)  # 初始化账户，初始资金 10 万美元
initOrders(portfolio=portfolio1.st)  # 初始化订单簿
# osFUN 需要知道哪个标的是第一腿、哪个是第二腿，以及 MaxPos 和 lvls 的值。
# 因此，在投资组合中创建一个插槽来存储这些信息。
pair <- c(1, 2, MaxPos, lvls)
names(pair) <- c(symb1, symb2, "MaxPos", "lvls")
.blotter[[paste('portfolio', portfolio1.st, sep='.')]]$pair <- pair  # 存储到组合属性中
# 按标的创建初始头寸限制和水平
# 如果 lvls=3，则允许多空各 3 次建仓。
addPosLimit(portfolio=portfolio1.st, timestamp=startDate, symbol=symb1,
maxpos=MaxPos, longlevels=lvls, minpos=-MaxPos, shortlevels=lvls)
addPosLimit(portfolio=portfolio1.st, timestamp=startDate, symbol=symb2,
maxpos=MaxPos, longlevels=lvls, minpos=-MaxPos, shortlevels=lvls)
# 创建策略对象
pairStrat <- strategy('pairStrat')
# 指标函数：计算两只股票的价格比率
calcRatio <- function(x) {
# 返回两只股票的名义收盘价比率
x1 <- get(x[1])
x2 <- get(x[2])
mult1 <- getInstrument(x[1])$multiplier  # 合约乘数
mult2 <- getInstrument(x[2])$multiplier
rat <- (mult1 * Cl(x1)) / (mult2 * Cl(x2))  # 收盘价比率
colnames(rat) <- 'Ratio'
rat
}
# 用于确定入场/出场的指标：比率及其布林带
Ratio <- calcRatio(c(symb1[1], symb2[1]))
# 将对冲比率存储在投资组合中，以便订单规模函数使用。
# 在本示例中，对冲比率与 Ratio 指标相同。
.blotter[[paste('portfolio',portfolio1.st,sep='.')]]$HedgeRatio <- Ratio
# 创建获取最新对冲比率的函数
getHedgeRatio <- function(portfolio, timestamp) {
portf <- getPortfolio(portfolio)
timestamp <- format(timestamp,"%Y-%m-%d %H:%M:%S")  # 格式化时间戳
# 上述行确保在使用日内数据且时间戳为午夜时，不会获取次日的最后一个值
toDate <- paste("::", timestamp, sep="")
Ratio <- last(portf$HedgeRatio[toDate])  # 获取该时间点的最新比率
as.numeric(Ratio)
}
# 添加指标：比率的布林带
pairStrat <- add.indicator(strategy=pairStrat, name = "calcRatio",
arguments=list(x=c(symb1,symb2)))
pairStrat <- add.indicator(strategy=pairStrat, name = "BBands",
arguments=list(HLC=quote(Ratio), sd=SD, n=N,
maType='SMA'))  # 基于 20 日 SMA 计算布林带
# 生成信号：当比率从下方穿过下轨时买入，从上方穿过上轨时卖出，穿过中轨时平仓
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","up"),
relationship="lt"),  # 比率 < 上轨（从上方穿过）
label="cross.up")
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","dn"),
relationship="gt"),  # 比率 > 下轨（从下方穿过）
label="cross.dn")
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","mavg"),
relationship="lt"),  # 比率 < 中轨（从上方穿过）
label="cross.mid.fa")
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","mavg"),
relationship="gt"),  # 比率 > 中轨（从下方穿过）
label="cross.mid.fb")
# 自定义订单规模函数
#######################_ORDER SIZING FUNCTION_##################################
osSpreadMaxPos <- function (data, timestamp, orderqty, ordertype, orderside,
portfolio, symbol, ruletype, ..., orderprice) {
portf <- getPortfolio(portfolio)
# 检查 pair 插槽是否包含该函数所需的内容
if (!any(portf$pair == 1) && !(any(portf$pair == 2)))
stop('pair 必须包含值 1 和 2')
if (!any(names(portf$pair) == "MaxPos") || !any(names(portf$pair) == "lvls"))
stop('pair 必须包含 MaxPos 和 lvls')
if (portf$pair[symbol] == 1) legside <- "long"  # 第一腿
if (portf$pair[symbol] == 2) legside <- "short"  # 第二腿（与第一腿方向相反）
MaxPos <- portf$pair["MaxPos"]
lvls <- portf$pair["lvls"]
ratio <- getHedgeRatio(portfolio, timestamp)  # 获取当前对冲比率
pos <- getPosQty(portfolio, symbol, timestamp)  # 当前头寸
PosLimit <- getPosLimit(portfolio, symbol, timestamp)  # 头寸限制
qty <- orderqty
if (legside == "short") {# 标的是第二腿
## 注释掉下一行可使每只股票的订单规模相等。
addPosLimit(portfolio=portfolio, timestamp=timestamp, symbol=symbol,
maxpos=round(MaxPos*ratio,0), longlevels=lvls,
minpos=round(-MaxPos*ratio,0), shortlevels=lvls)  # 调整第二腿的头寸限制
##
qty <- -orderqty  # 反转股票 B 的订单数量（多空相反）
}
if (qty > 0) orderside = 'long'  # 确定订单方向
if (qty < 0) orderside = 'short'
# 调用 osMaxPos 计算符合头寸限制的订单数量
orderqty <- osMaxPos(data=data,timestamp=timestamp, orderqty=qty,
ordertype=ordertype, orderside=orderside,
portfolio=portfolio, symbol=symbol, ruletype=ruletype,
...)
# 在规则信号函数中添加订单
if (!is.null(orderqty) & !orderqty == 0 & !is.null(orderprice)) {
addOrder(portfolio=portfolio, symbol=symbol,
timestamp=timestamp, qty=orderqty, price=as.numeric(orderprice),
ordertype=ordertype, side=orderside, replace=FALSE,
status="open", ...=...)
}
return(0)  # 使 ruleSignal 函数不会尝试下单
}
################################################################################
# 为多空方向创建入场和出场规则。两个标的将获得相同的买卖信号，
# 但 osMaxPos 会为第二个标的反转这些信号。
# orderqty 大于头寸限制允许的值。osMaxPos 会将订单数量调整为最大允许值的 1/3。
# （1/3 是因为我们在 PosLimit 中使用了 3 个水平）
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.dn", sigval=TRUE,
orderqty=1e6, ordertype='market',
orderside=NULL, osFUN='osSpreadMaxPos'),
type='enter')  # cross.dn 信号触发入场
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.up", sigval=TRUE,
orderqty=-1e6, ordertype='market',
orderside=NULL, osFUN='osSpreadMaxPos'),
type='enter')  # cross.up 信号触发入场
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.mid.fb", sigval=TRUE,
orderqty='all', ordertype='market',
orderside=NULL),
type='exit')  # cross.mid.fb 信号触发出场
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.mid.fa", sigval=TRUE,
orderqty='all', ordertype='market',
orderside=NULL),
type='exit')  # cross.mid.fa 信号触发出场
# 执行策略回测
out1<-applyStrategy(strategy=pairStrat, portfolios=portfolio1.st)
# 更新组合和账户数据
updatePortf(Portfolio=portfolio1.st,
Dates=paste("::", as.Date(Sys.time()), sep=''))
updateAcct(account.st, Dates=paste(startDate, endDate, sep="::"))
updateEndEq(account.st, Dates=paste(startDate, endDate, sep="::"))
getEndEq(account.st, Sys.time())  # 查看最终权益
# 绘制持仓图表
dev.new()
chart.Posn(Portfolio=portfolio1.st, Symbol=symb1)  # 股票 1 的持仓图
dev.new()
chart.Posn(Portfolio=portfolio1.st, Symbol=symb2)  # 股票 2 的持仓图
dev.new()
chartSeries(Cl(get(symb1))/Cl(get(symb2)), TA="addBBands(n=N,sd=SD)")  # 比率与布林带图
# 绩效分析
ret1 <- PortfReturns(account.st)  # 组合收益
ret1$total <- rowSums(ret1)  # 总收益
# 绘制绩效摘要
if("package:PerformanceAnalytics" %in% search() ||
require("PerformanceAnalytics",quietly=TRUE)) {
dev.new()
charts.PerformanceSummary(ret1$total, geometric=FALSE, wealth.index=TRUE)  # 收益摘要图
}
# Kindly contributed to quantstrat by Garrett See
# code borrowed heavily from existing quantstrat demos
# 这是一个简单的配对交易示例，旨在展示如何扩展现有 quantstrat 功能。
# 它使用 addPosLimits 指定头寸水平和限制，并演示如何将自定义订单规模函数传递给 osFUN
# 注意：先构建价差并将其视为单一工具，比处理股票组合更简单
## 给定两只股票，计算其名义价值比率。如果比率低于 2 标准差区间，
# 当它回升穿过区间时，买入股票 1 并卖出股票 2。如果比率高于 2 标准差区间，
# 当它回落穿过区间时，卖出股票 1 并买入股票 2。如果比率穿过其移动平均线，则平仓所有头寸。
# 股票 A 的买入（卖出）数量 = MaxPos / lvls
# 股票 B 的卖出（买入）数量 = MaxPos * 比率 / lvls
require(quantstrat)
suppressWarnings(rm("order_book.pair1",pos=.strategy))
suppressWarnings(rm("account.pairs", "portfolio.pair1", pos=.blotter))
suppressWarnings(rm("startDate", "endDate", "startDate", "initEq", "SD", "N",
"symb1", "symb2", "portfolio1.st", "account.st",
"pairStrat", "out1"))
startDate <- '2009-01-01'
endDate <- '2011-05-01'
startDate <- '2009-01-02'
initEq <- 100000
SD <- 2  # 标准差倍数
N <- 20  # 移动平均线周期
MaxPos <- 1500  # 股票 A 的最大头寸；
# 股票 B 的最大头寸将是 max * 比率，即对股票 B 没有硬性头寸限制
lvls <- 3  # 分几步建仓；每笔订单数量 = MaxPos/lvls
symb1 <- 'SPY'  # 可更改这些标的以尝试其他配对
symb2 <- 'DIA'  # 如果更改，需确保头寸限制仍然合理
portfolio1.st <- 'pair1'
account.st <- 'pairs'
# 获取历史数据
getSymbols(c(symb1, symb2), from=startDate, to=endDate, adjust=TRUE)
# 以下函数用于确保所有标的的时间戳相同，删除其中一只股票数据缺失的行
alignSymbols <- function(symbols, env=.GlobalEnv) {
# 这是 qmao::alignSymbols() 的简化版本
if (length(symbols) < 2)
stop("必须提供至少 2 个标的")
if (any(!is.character(symbols)))
stop("标的必须是字符向量。")
ff <- get(symbols[1],env=env)
for (sym in symbols[-1]) {
tmp.sym <- get(sym,env=env)
ff <- merge(ff, tmp.sym, all=FALSE)  # 只保留双方都有数据的行
}
for (sym in symbols) {
assign(sym,ff[,grep(sym, colnames(ff))], env=env)  # 更新标的数据
}
symbols
}
alignSymbols(c(symb1, symb2))  # 对齐两只股票的时间戳
# 定义金融工具
currency("USD")  # 基础货币为美元
stock(symb1, currency="USD", multiplier=1)  # 定义股票 1 的属性
stock(symb2, currency="USD", multiplier=1)  # 定义股票 2 的属性
# 初始化投资组合、账户和订单
initPortf(name=portfolio1.st, c(symb1,symb2))  # 创建包含两只股票的组合
initAcct(account.st, portfolios=portfolio1.st, initEq=initEq)  # 初始化账户，初始资金 10 万美元
initOrders(portfolio=portfolio1.st)  # 初始化订单簿
# osFUN 需要知道哪个标的是第一腿、哪个是第二腿，以及 MaxPos 和 lvls 的值。
# 因此，在投资组合中创建一个插槽来存储这些信息。
pair <- c(1, 2, MaxPos, lvls)
names(pair) <- c(symb1, symb2, "MaxPos", "lvls")
.blotter[[paste('portfolio', portfolio1.st, sep='.')]]$pair <- pair  # 存储到组合属性中
# 按标的创建初始头寸限制和水平
# 如果 lvls=3，则允许多空各 3 次建仓。
addPosLimit(portfolio=portfolio1.st, timestamp=startDate, symbol=symb1,
maxpos=MaxPos, longlevels=lvls, minpos=-MaxPos, shortlevels=lvls)
addPosLimit(portfolio=portfolio1.st, timestamp=startDate, symbol=symb2,
maxpos=MaxPos, longlevels=lvls, minpos=-MaxPos, shortlevels=lvls)
# 创建策略对象
pairStrat <- strategy('pairStrat')
# 指标函数：计算两只股票的价格比率
calcRatio <- function(x) {
# 返回两只股票的名义收盘价比率
x1 <- get(x[1])
x2 <- get(x[2])
mult1 <- getInstrument(x[1])$multiplier  # 合约乘数
mult2 <- getInstrument(x[2])$multiplier
rat <- (mult1 * Cl(x1)) / (mult2 * Cl(x2))  # 收盘价比率
colnames(rat) <- 'Ratio'
rat
}
# 用于确定入场/出场的指标：比率及其布林带
Ratio <- calcRatio(c(symb1[1], symb2[1]))
# 将对冲比率存储在投资组合中，以便订单规模函数使用。
# 在本示例中，对冲比率与 Ratio 指标相同。
.blotter[[paste('portfolio',portfolio1.st,sep='.')]]$HedgeRatio <- Ratio
# 创建获取最新对冲比率的函数
getHedgeRatio <- function(portfolio, timestamp) {
portf <- getPortfolio(portfolio)
timestamp <- format(timestamp,"%Y-%m-%d %H:%M:%S")  # 格式化时间戳
# 上述行确保在使用日内数据且时间戳为午夜时，不会获取次日的最后一个值
toDate <- paste("::", timestamp, sep="")
Ratio <- last(portf$HedgeRatio[toDate])  # 获取该时间点的最新比率
as.numeric(Ratio)
}
# 添加指标：比率的布林带
pairStrat <- add.indicator(strategy=pairStrat, name = "calcRatio",
arguments=list(x=c(symb1,symb2)))
pairStrat <- add.indicator(strategy=pairStrat, name = "BBands",
arguments=list(HLC=quote(Ratio), sd=SD, n=N,
maType='SMA'))  # 基于 20 日 SMA 计算布林带
# 生成信号：当比率从下方穿过下轨时买入，从上方穿过上轨时卖出，穿过中轨时平仓
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","up"),
relationship="lt"),  # 比率 < 上轨（从上方穿过）
label="cross.up")
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","dn"),
relationship="gt"),  # 比率 > 下轨（从下方穿过）
label="cross.dn")
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","mavg"),
relationship="lt"),  # 比率 < 中轨（从上方穿过）
label="cross.mid.fa")
pairStrat <- add.signal(strategy=pairStrat, name="sigCrossover",
arguments=list(columns=c("Ratio","mavg"),
relationship="gt"),  # 比率 > 中轨（从下方穿过）
label="cross.mid.fb")
# 自定义订单规模函数
#######################_ORDER SIZING FUNCTION_##################################
osSpreadMaxPos <- function (data, timestamp, orderqty, ordertype, orderside,
portfolio, symbol, ruletype, ..., orderprice) {
portf <- getPortfolio(portfolio)
# 检查 pair 插槽是否包含该函数所需的内容
if (!any(portf$pair == 1) && !(any(portf$pair == 2)))
stop('pair 必须包含值 1 和 2')
if (!any(names(portf$pair) == "MaxPos") || !any(names(portf$pair) == "lvls"))
stop('pair 必须包含 MaxPos 和 lvls')
if (portf$pair[symbol] == 1) legside <- "long"  # 第一腿
if (portf$pair[symbol] == 2) legside <- "short"  # 第二腿（与第一腿方向相反）
MaxPos <- portf$pair["MaxPos"]
lvls <- portf$pair["lvls"]
ratio <- getHedgeRatio(portfolio, timestamp)  # 获取当前对冲比率
pos <- getPosQty(portfolio, symbol, timestamp)  # 当前头寸
PosLimit <- getPosLimit(portfolio, symbol, timestamp)  # 头寸限制
qty <- orderqty
if (legside == "short") {# 标的是第二腿
## 注释掉下一行可使每只股票的订单规模相等。
addPosLimit(portfolio=portfolio, timestamp=timestamp, symbol=symbol,
maxpos=round(MaxPos*ratio,0), longlevels=lvls,
minpos=round(-MaxPos*ratio,0), shortlevels=lvls)  # 调整第二腿的头寸限制
##
qty <- -orderqty  # 反转股票 B 的订单数量（多空相反）
}
if (qty > 0) orderside = 'long'  # 确定订单方向
if (qty < 0) orderside = 'short'
# 调用 osMaxPos 计算符合头寸限制的订单数量
orderqty <- osMaxPos(data=data,timestamp=timestamp, orderqty=qty,
ordertype=ordertype, orderside=orderside,
portfolio=portfolio, symbol=symbol, ruletype=ruletype,
...)
# 在规则信号函数中添加订单
if (!is.null(orderqty) & !orderqty == 0 & !is.null(orderprice)) {
addOrder(portfolio=portfolio, symbol=symbol,
timestamp=timestamp, qty=orderqty, price=as.numeric(orderprice),
ordertype=ordertype, side=orderside, replace=FALSE,
status="open", ...=...)
}
return(0)  # 使 ruleSignal 函数不会尝试下单
}
################################################################################
# 为多空方向创建入场和出场规则。两个标的将获得相同的买卖信号，
# 但 osMaxPos 会为第二个标的反转这些信号。
# orderqty 大于头寸限制允许的值。osMaxPos 会将订单数量调整为最大允许值的 1/3。
# （1/3 是因为我们在 PosLimit 中使用了 3 个水平）
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.dn", sigval=TRUE,
orderqty=1e6, ordertype='market',
orderside=NULL, osFUN='osSpreadMaxPos'),
type='enter')  # cross.dn 信号触发入场
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.up", sigval=TRUE,
orderqty=-1e6, ordertype='market',
orderside=NULL, osFUN='osSpreadMaxPos'),
type='enter')  # cross.up 信号触发入场
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.mid.fb", sigval=TRUE,
orderqty='all', ordertype='market',
orderside=NULL),
type='exit')  # cross.mid.fb 信号触发出场
pairStrat <- add.rule(strategy=pairStrat, name='ruleSignal',
arguments=list(sigcol="cross.mid.fa", sigval=TRUE,
orderqty='all', ordertype='market',
orderside=NULL),
type='exit')  # cross.mid.fa 信号触发出场
# 执行策略回测
out1<-applyStrategy(strategy=pairStrat, portfolios=portfolio1.st)
# 更新组合和账户数据
updatePortf(Portfolio=portfolio1.st,
Dates=paste("::", as.Date(Sys.time()), sep=''))
updateAcct(account.st, Dates=paste(startDate, endDate, sep="::"))
updateEndEq(account.st, Dates=paste(startDate, endDate, sep="::"))
getEndEq(account.st, Sys.time())  # 查看最终权益
# 绘制持仓图表
dev.new()
chart.Posn(Portfolio=portfolio1.st, Symbol=symb1)  # 股票 1 的持仓图
dev.new()
chart.Posn(Portfolio=portfolio1.st, Symbol=symb2)  # 股票 2 的持仓图
dev.new()
chartSeries(Cl(get(symb1))/Cl(get(symb2)), TA="addBBands(n=N,sd=SD)")  # 比率与布林带图
# 绩效分析
ret1 <- PortfReturns(account.st)  # 组合收益
ret1$total <- rowSums(ret1)  # 总收益
# 绘制绩效摘要
if("package:PerformanceAnalytics" %in% search() ||
require("PerformanceAnalytics",quietly=TRUE)) {
dev.new()
charts.PerformanceSummary(ret1$total, geometric=FALSE, wealth.index=TRUE)  # 收益摘要图
}
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()
q()
#
# 基于Jaekle & Tamasini所著《A new approach to system development and portfolio optimisation》
# （ISBN 978-1-905641-79-6）
#
# 前进测试图表示例
# 加载quantstrat包，该包提供量化策略开发、回测及可视化工具
require('quantstrat')
# 绘制前进测试训练期的图表
# 数据来源为quantstrat包内置的Luxor系统前进测试示例数据（luxor.wfa.ples.RData）
chart.forward.training(
paste0(path.package("quantstrat"), '/data/luxor.wfa.ples.RData')  # 前进测试结果数据路径
)
paste0(path.package("quantstrat"), '/data/luxor.wfa.ples.RData'
)
?quantstrat
luxoraudit
data(
luxoraudit )
luxoraudit
data(luxoraudit)
luxoraudit
blogdown:::serve_site()
blogdown::serve_site()
data("luxoraudit")
luxoraudit
# 构建完整路径
data_path <- paste0(path.package("quantstrat"), '/data/luxor.wfa.ples.RData')
# 加载数据文件
if (file.exists(data_path)) {
load(data_path)  # 加载文件中的审计环境数据（如策略参数、绩效记录等）
ls()  # 查看加载的对象（通常包含前进测试的审计信息）
}
View(luxoraudit)
chart.forward.training(luxoraudit) #
# 构建完整路径
data_path <- paste0(path.package("quantstrat"), '/data/luxor.wfa.ples.RData')
# 加载数据文件
if (file.exists(data_path)) {
load(data_path)  # 加载文件中的审计环境数据（如策略参数、绩效记录等）
ls()  # 查看加载的对象（通常包含前进测试的审计信息）
}
chart.forward.training(luxoraudit)
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
# 基于Jaekle & Tamasini所著《A new approach to system development and portfolio optimisation》
#
# 3D时间跨度图表示例
# 加载必要的包：quantstrat用于量化策略分析，rgl用于3D图形绘制
require(quantstrat)
require(rgl)
# 加载Luxor策略的时间跨度数据：包含2002-2008年24x24时间窗口的测试结果
# 数据路径为quantstrat包安装目录下的data文件夹
load(paste0(
path.package('quantstrat'),  # 获取quantstrat包的安装路径
'/data/luxor.timespan.24x24.2002-2008.RData')  # 拼接数据文件完整路径
)
# 数据预处理：将stats数据框中存储参数的列重命名为"timespan"，便于后续处理
names(stats)[names(stats)=='testPackListPRL[[k]]$parameters'] <- 'timespan'
# 分割timespan列：timespan格式可能为"开始时间/结束时间"，用strsplit分割为列表
stats$tmp = strsplit(as.character(stats$timespan), '/')
# 从分割后的列表中提取"from"（开始时间）和"to"（结束时间），存储为新列
stats$from <- sapply(stats$tmp, FUN = '[', 1)  # 提取列表中第一个元素作为开始时间
stats$to <- sapply(stats$tmp, FUN = '[', 2)    # 提取列表中第二个元素作为结束时间
# 从开始时间和结束时间中提取小时数：假设时间格式含"T小时:分钟"，用gsub匹配并提取小时
stats$start <- as.numeric(gsub('T([0-9]+):[0-9]+', x = stats$from, '\\1'))  # 提取开始小时
stats$stop <- (as.numeric(gsub('T([0-9]+):[0-9]+', x = stats$to, '\\1')) + 1) %% 24  # 提取结束小时并调整（+1取整，%%24确保在0-23范围内）
# 注释部分：交易数据为EST时区（GMT-4），可将小时数加4转换为GMT时区（按需启用）
# stats$start<-(stats$start+4)%%24
# stats$stop<-(stats$stop+4)%%24
# 生成3D可视化图形：展示不同时间窗口（start和stop）与绩效指标的关系
tradeGraphs(
stats,  # 输入数据框
free.params = c('start', 'stop'),  # 自由参数：时间窗口的开始和结束小时
statistics = c('Net.Trading.PL', 'maxDrawdown', "Avg.Trade.PL", 'Num.Trades', "Profit.Factor"),  # 需展示的绩效指标：净交易收益、最大回撤、平均每笔收益、交易次数、盈利因子
title = 'Luxor Intraday TimeWindow Scan'  # 图形标题：Luxor日内时间窗口扫描
)
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
# 基于Jaekle & Tamasini所著《A new approach to system development and portfolio optimisation》
#
# 图3.16：百分比形式的MFE（最大有利波动）图形
# 加载blotter包，用于交易组合的记录与绩效分析
require('blotter')
# 加载Luxor策略的交易数据（对应书中第66页的示例），存储到blotter环境中
# 数据包含GBPUSD的交易记录，如入场时间、价格、持仓变化等
data('luxor-p066', package='quantstrat', envir=.blotter)
# 定义货币单位：GBP（英镑）和USD（美元），因交易标的为GBPUSD（英镑兑美元）
currency(c('GBP', 'USD'))
# 定义汇率属性：GBPUSD的最小变动单位（点差）为0.0001
exchange_rate(c('GBPUSD'), tick_size=0.0001)
# 绘制MFE图形（百分比形式）
chart.ME(
Portfolio='luxor',  # 组合名称：luxor（对应加载的数据）
Symbol='GBPUSD',    # 交易标的：英镑兑美元
type='MFE',         # 图形类型：最大有利波动（MFE）
scale='percent'     # 刻度单位：百分比（展示价格波动相对于入场价的百分比）
)
blogdown:::serve_site()
blogdown:::stop_server()
# 基于Jaekle & Tamasini所著《A new approach to system development and portfolio optimisation》
#
# 图3.16：百分比形式的MFE（最大有利波动）图形
# 加载blotter包，用于交易组合的记录与绩效分析
require('blotter')
# 加载Luxor策略的交易数据（对应书中第66页的示例）
# envir=.blotter参数将数据加载到blotter包的环境中，便于后续分析
data('luxor-p066', package='quantstrat', envir=.blotter)
# 定义货币单位与汇率属性：设置交易涉及的货币及GBPUSD的最小变动单位
currency(c('GBP', 'USD'))  # 定义英镑和美元为交易货币
exchange_rate(c('GBPUSD'), tick_size=0.0001)  # 设置GBPUSD的最小价格变动为0.0001（即1个点）
# 绘制MFE图表：以百分比形式展示每笔交易的最大有利波动
chart.ME(
Portfolio='luxor',  # 指定要分析的投资组合名称
Symbol='GBPUSD',    # 指定要分析的交易品种（GBPUSD货币对）
type='MFE',         # 指定图表类型为MFE（最大有利波动）
scale='percent'     # 指定Y轴刻度为百分比形式（相对于入场价格的波动比例）
)
blogdown:::stop_server()
blogdown:::serve_site()
blogdown:::stop_server()
blogdown:::serve_site()

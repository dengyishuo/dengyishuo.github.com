geom_hline(yintercept = var_99,
color = "blue",
linetype = "dashed") +
geom_hline(yintercept = var_995,
color = "black",
linetype = "dashed") +
labs(title = "TSLA极端损失与EVT-GPD VaR",x = "日期", y = "极端损失（绝对值）") +
theme_minimal()
blogdown:::serve_site()
blogdown::stop_server()
blogdown:::serve_site()
blogdown:::new_post_addin()
blogdown:::stop_server()
# 加载必要的包
library(quantmod)
library(PerformanceAnalytics)
library(xts)
library(showtext)  # 用于设置中文字体
# 设置中文字体
font_add("SimHei", "SimHei.ttf")  # 如果字体已安装
# 如果字体未安装，可以尝试系统字体路径
# font_add("SimHei", "/path/to/SimHei.ttf")  # Linux/Mac
# font_add("SimHei", "C:/Windows/Fonts/simhei.ttf")  # Windows
showtext_auto()  # 自动启用showtext
# 获取纳斯达克综合指数数据
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
# 计算日对数收益率
returns <- diff(log(Cl(IXIC)))
returns <- na.omit(returns)
# 设置置信水平
alpha <- 0.95
# 使用PerformanceAnalytics包计算ES
library(PerformanceAnalytics)
es_historical <- ES(returns, p = alpha, method = "historical")
es_gaussian <- ES(returns, p = alpha, method = "gaussian")
cat("PerformanceAnalytics包计算结果:\n")
cat("历史模拟法 ES:", round(es_historical * 100, 2), "%\n")
cat("正态分布假设 ES:", round(es_gaussian * 100, 2), "%\n")
# 使用RiskPortfolios包计算ES
library(RiskPortfolios)
es_riskport <- ES(returns, alpha = 1 - alpha)
cat("\nRiskPortfolios包计算结果:\n")
cat("ES:", round(es_riskport * 100, 2), "%\n")
# 使用fGarch包计算ES
library(fGarch)
es_empirical <- ES.empirical(returns, p = alpha)
# 拟合GARCH模型并预测
garch_model <- garchFit(~garch(1,1), data = returns, trace = FALSE)
forecast <- predict(garch_model, n.ahead = 1)
es_garch <- ES.normal(mean = forecast$meanForecast,
sd = forecast$standardDeviation,
p = alpha)
cat("\nfGarch包计算结果:\n")
cat("历史模拟法 ES:", round(es_empirical * 100, 2), "%\n")
cat("GARCH模型预测 ES:", round(es_garch * 100, 2), "%\n")
library(fGarch)
?fGarch
es_empirical <- ES(returns, p = alpha)
# 拟合GARCH模型并预测
garch_model <- garchFit(~garch(1,1), data = returns, trace = FALSE)
forecast <- predict(garch_model, n.ahead = 1)
# 拟合GARCH模型并预测
garch_model <- garchFit(~garch(1,1), data = returns, trace = FALSE)
forecast <- predict(garch_model, n.ahead = 1)
es_garch <- ES(garch_model)
# 使用fGarch包计算ES
library(fGarch)
es_empirical <- ES(returns, p = alpha)
# 拟合GARCH模型并预测
garch_model <- garchFit(~garch(1,1), data = returns, trace = FALSE)
forecast <- predict(garch_model, n.ahead = 1)
es_garch <- ES(garch_model)
cat("\nfGarch包计算结果:\n")
cat("历史模拟法 ES:", round(es_empirical * 100, 2), "%\n")
cat("GARCH模型预测 ES:", round(es_garch * 100, 2), "%\n")
es_empirical <- ES(returns, p = alpha)
# 使用fGarch包计算ES
library(fGarch)
# 拟合GARCH模型并预测
garch_model <- garchFit(~garch(1,1), data = returns, trace = FALSE)
forecast <- predict(garch_model, n.ahead = 1)
es_garch <- ES(garch_model)
cat("\nfGarch包计算结果:\n")
cat("历史模拟法 ES:", round(es_empirical * 100, 2), "%\n")
cat("GARCH模型预测 ES:", round(es_garch * 100, 2), "%\n")
# 使用fGarch包计算ES
library(fGarch)
# 拟合GARCH模型并预测
garch_model <- garchFit(~garch(1,1), data = returns, trace = FALSE)
forecast <- predict(garch_model, n.ahead = 1)
es_garch <- tail(ES(garch_model))
cat("\nfGarch包计算结果:\n")
cat("GARCH模型预测 ES:", round(es_garch * 100, 2), "%\n")
# 使用ExpectedShortfall包计算ES
library(ExpectedShortfall)
install.packages("ExpectedShortfall")
# 使用rugarch包计算ES
library(rugarch)
# 定义GARCH模型
spec <- ugarchspec(variance.model = list(model = "sGARCH"),
mean.model = list(armaOrder = c(0,0)))
fit <- ugarchfit(spec, data = returns, solver = "hybrid")
# 计算ES
risk_metrics <- riskmetrics(fit, n.ahead = 1, conf.level = alpha)
es_rugarch <- risk_metrics$ES
cat("\nrugarch包计算结果:\n")
cat("GARCH模型 ES:", round(es_rugarch * 100, 2), "%\n")
library(rugarch)
?rugarch
installl.packages("ES")
install.packages("ES")
library(estimability)
library(ES)
# 使用PerformanceAnalytics包计算ES
library(PerformanceAnalytics)
es_historical <- ES(returns, p = alpha, method = "historical")
es_gaussian <- ES(returns, p = alpha, method = "gaussian")
cat("PerformanceAnalytics包计算结果:\n")
cat("历史模拟法 ES:", round(es_historical * 100, 2), "%\n")
cat("正态分布假设 ES:", round(es_gaussian * 100, 2), "%\n")
# 加载必要的包
library(quantmod)
library(PerformanceAnalytics)
library(xts)
library(showtext)  # 用于设置中文字体
# 设置中文字体
font_add("SimHei", "SimHei.ttf")  # 如果字体已安装
# 如果字体未安装，可以尝试系统字体路径
# font_add("SimHei", "/path/to/SimHei.ttf")  # Linux/Mac
# font_add("SimHei", "C:/Windows/Fonts/simhei.ttf")  # Windows
showtext_auto()  # 自动启用showtext
# 获取纳斯达克综合指数数据
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
# 计算日对数收益率
returns <- diff(log(Cl(IXIC)))
returns <- na.omit(returns)
# 设置置信水平
alpha <- 0.95
# 使用PerformanceAnalytics包计算ES
library(PerformanceAnalytics)
es_historical <- ES(returns, p = alpha, method = "historical")
es_gaussian <- ES(returns, p = alpha, method = "gaussian")
cat("PerformanceAnalytics包计算结果:\n")
cat("历史模拟法 ES:", round(es_historical * 100, 2), "%\n")
cat("正态分布假设 ES:", round(es_gaussian * 100, 2), "%\n")
?ES
# 使用PerformanceAnalytics包计算ES
library(PerformanceAnalytics)
es_historical <- PerformanceAnalytics::ES(returns, p = alpha, method = "historical")
es_gaussian <- PerformanceAnalytics::ES(returns, p = alpha, method = "gaussian")
cat("PerformanceAnalytics包计算结果:\n")
cat("历史模拟法 ES:", round(es_historical * 100, 2), "%\n")
cat("正态分布假设 ES:", round(es_gaussian * 100, 2), "%\n")
# 使用RiskPortfolios包计算ES
library(RiskPortfolios)
es_riskport <- RiskPortfolios::ES(returns, alpha = 1 - alpha)
cat("\nRiskPortfolios包计算结果:\n")
cat("ES:", round(es_riskport * 100, 2), "%\n")
?RiskPortfolios
# 使用fGarch包计算ES
library(fGarch)
# 拟合GARCH模型并预测
garch_model <- garchFit(~garch(1,1), data = returns, trace = FALSE)
forecast <- predict(garch_model, n.ahead = 1)
es_garch <- tail(ES(garch_model))
cat("\nfGarch包计算结果:\n")
cat("GARCH模型预测 ES:", round(es_garch * 100, 2), "%\n")
if (!require("cvar")) install.packages("cvar")
library(cvar)
# 基于正态分布的参数法计算
norm_spec <- list(
qf = function(p) qnorm(p, mean = mean(returns), sd = sd(returns)),  # 分位数函数
cdf = function(x) pnorm(x, mean = mean(returns), sd = sd(returns)),  # 累积分布函数
pdf = function(x) dnorm(x, mean = mean(returns), sd = sd(returns))   # 密度函数
)
risk_results[["cvar"]] <- list(
VaR = cvar::VaR(norm_spec, alpha = 1 - alpha),
ES = cvar::ES(norm_spec, alpha = 1 - alpha)
)
?cvar::ES
if (!require("cvar")) install.packages("cvar")
library(cvar)
# 基于正态分布的参数法计算
norm_spec <- list(
qf = function(p) qnorm(p, mean = mean(returns), sd = sd(returns)),  # 分位数函数
cdf = function(x) pnorm(x, mean = mean(returns), sd = sd(returns)),  # 累积分布函数
pdf = function(x) dnorm(x, mean = mean(returns), sd = sd(returns))   # 密度函数
)
risk_results[["cvar"]] <- list(
VaR = cvar::VaR(norm_spec, alpha = 1 - alpha),
ES = cvar::ES(norm_spec, alpha = 1 - alpha)
)
if (!require("cvar")) install.packages("cvar")
library(cvar)
# 标准正态分布计算
gaussian_es <- list(
qf = cvar::ES(qnorm, dist.type = "qf"),  # 使用分位数函数
cdf = cvar::ES(pnorm, dist.type = "cdf")  # 使用累积分布函数
)
# t分布计算（df=4）
t_dist_es <- list(
qf = cvar::ES(qt, dist.type = "qf", df = 4),
cdf = cvar::ES(pt, dist.type = "cdf", df = 4)
)
# 指定置信水平95%的计算
alpha_95 <- list(
qf_norm = cvar::ES(qnorm, 0.95, dist.type = "qf"),
cdf_norm = cvar::ES(pnorm, 0.05, dist.type = "cdf"),  # 注意概率水平转换
pdf_norm = cvar::ES(dnorm, 0.05, dist.type = "pdf", qf = qnorm)
)
# 使用rugarch包计算ES
library(rugarch)
# 定义GARCH模型
spec <- ugarchspec(variance.model = list(model = "sGARCH"),
mean.model = list(armaOrder = c(0,0)))
fit <- ugarchfit(spec, data = returns, solver = "hybrid")
# 计算ES
risk_metrics <- riskmetrics(fit, n.ahead = 1, conf.level = alpha)
es_rugarch <- risk_metrics$ES
cat("\nrugarch包计算结果:\n")
cat("GARCH模型 ES:", round(es_rugarch * 100, 2), "%\n")
？rugarch
?rugarch
returns
fit <- ugarchfit(spec, data = returns, solver = "hybrid")
spec2 = spec
setfixed(spec2)<-as.list(coef(fit))
spec2 = spec
setfixed(spec2)<-as.list(coef(fit))
filt = ugarchfilter(spec2, returns, 1, drop = FALSE], n.old = 1000)
filt = ugarchfilter(spec2, returns, 1, drop = FALSE, n.old = 1000)
spec2 = spec
setfixed(spec2)<-as.list(coef(fit))
filt = ugarchfilter(spec2, returns,n.old = 1000)
# 计算ES
# location+scale invariance allows to use [mu + sigma*q(p,0,1,skew,shape)]
VaR = fitted(filt) + sigma(filt)*qdist("sstd", p=0.05, mu = 0, sigma = 1,
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
# calculate ES
f = function(x) qdist("sstd", p=x, mu = 0, sigma = 1,
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
ES = fitted(filt) + sigma(filt)*integrate(f, 0, 0.05)$value/0.05
print(ESTest(0.05, actual, ES, VaR, boot = TRUE))
# 使用rugarch包计算ES
library(rugarch)
# 定义GARCH模型
spec <- ugarchspec(variance.model = list(model = "sGARCH"),
mean.model = list(armaOrder = c(0,0)))
fit <- ugarchfit(spec, data = returns, solver = "hybrid")
spec2 = spec
setfixed(spec2)<-as.list(coef(fit))
filt = ugarchfilter(spec2, returns,n.old = 1000)
actual = returns
# 计算ES
# location+scale invariance allows to use [mu + sigma*q(p,0,1,skew,shape)]
VaR = fitted(filt) + sigma(filt)*qdist("sstd", p=0.05, mu = 0, sigma = 1,
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
# calculate ES
f = function(x) qdist("sstd", p=x, mu = 0, sigma = 1,
skew  = coef(fit)["skew"], shape=coef(fit)["shape"])
ES = fitted(filt) + sigma(filt)*integrate(f, 0, 0.05)$value/0.05
print(ESTest(0.05, actual, ES, VaR, boot = TRUE))
# 加载必要的包
library(rugarch)
library(xts)  # 处理时间序列数据
# 获取纳斯达克指数数据并计算收益率
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
returns <- diff(log(Cl(IXIC))) %>% na.omit()
# 定义GARCH模型（使用偏态t分布）
spec <- ugarchspec(
variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
mean.model = list(armaOrder = c(0, 0), include.mean = TRUE),
distribution.model = "sstd"  # 偏态t分布
)
# 拟合模型
fit <- ugarchfit(spec, data = returns, solver = "hybrid")
# 使用固定参数重新过滤数据
spec2 <- spec
setfixed(spec2) <- as.list(coef(fit))
filt <- ugarchfilter(spec2, data = returns, n.old = 1000)
# 提取拟合值和波动率
mu <- fitted(filt)       # 条件均值
sigma_t <- sigma(filt)@sigma.t  # 条件波动率
# 获取分布参数
skew <- coef(fit)["skew"]
shape <- coef(fit)["shape"]
# 计算VaR (使用向量化方法)
p <- 0.05  # 置信水平(1-95%)
VaR <- mu + sigma_t * qdist("sstd", p = p, mu = 0, sigma = 1, skew = skew, shape = shape)
# 计算ES (使用数值积分)
es_integrand <- function(x) {
qdist("sstd", p = x, mu = 0, sigma = 1, skew = skew, shape = shape)
}
# 向量化积分计算（对每个时间点单独计算ES）
ES <- numeric(length(returns))
for (i in 1:length(returns)) {
int_result <- integrate(es_integrand, lower = 0, upper = p, subdivisions = 1000)
ES[i] <- mu[i] + sigma_t[i] * int_result$value / p
}
# 确保所有向量长度一致（处理可能的长度差异）
min_len <- min(length(returns), length(VaR), length(ES))
actual <- as.numeric(tail(returns, min_len))
VaR <- as.numeric(tail(VaR, min_len))
ES <- as.numeric(tail(ES, min_len))
if (!require("gets")) install.packages("gets")
library(gets)
# 构建ARX模型（滞后1阶）
arx_model <- arx(returns ~ 1 + lags(returns, 1))
risk_results[["gets"]] <- list(
VaR = VaR(arx_model, level = 1 - alpha),
ES = ES(arx_model, level = 1 - alpha)
)
library(gets)
# 构建ARX模型（滞后1阶）
arx_model <- arx(returns ~ 1 + lags(returns, 1))
risk_results[["gets"]] <- list(
VaR = VaR(arx_model, level = 1 - alpha),
ES = ES(arx_model, level = 1 - alpha)
)
# 加载必要的包
library(quantmod)
library(gets)
library(xts)
# 获取纳斯达克指数数据并计算收益率
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
returns <- diff(log(Cl(IXIC))) %>% na.omit()
returns_vector <- as.numeric(returns)  # 转换为普通向量
# 设置置信水平
alpha <- 0.95
# 构建ARX模型（滞后1阶）
# 使用普通向量而非xts对象
arx_model <- arx(returns_vector ~ 1 + lags(returns_vector, 1))
# 计算VaR和ES
risk_results[["gets"]] <- list(
VaR = VaR(arx_model, level = 1 - alpha),
ES = ES(arx_model, level = 1 - alpha)
)
# 打印结果
cat("ARX模型风险度量结果:\n")
cat("VaR (", alpha*100, "%):", round(risk_results[["gets"]]$VaR*100, 2), "%\n")
cat("ES (", alpha*100, "%):", round(risk_results[["gets"]]$ES*100, 2), "%\n")
returns_vector <- as.numeric(returns)
arx_model <- arx(returns_vector ~ 1 + lags(returns_vector, 1))
?arx
# 获取纳斯达克指数数据并计算收益率
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
returns <- diff(log(Cl(IXIC))) %>% na.omit()
returns_vector <- as.numeric(returns)  # 转换为普通向量
# 设置置信水平
alpha <- 0.95
# 构建ARX模型（滞后1阶）
# 使用普通向量而非xts对象
arx_model <- arx(returns_vector ~ 1 + lags(returns_vector, 1))
# 计算VaR和ES
risk_results[["gets"]] <- list(
VaR = VaR(arx_model, level = 1 - alpha),
ES = ES(arx_model, level = 1 - alpha)
)
returns <- diff(log(Cl(IXIC)))
returns <- na.omit(returns)
returns_vector <- as.numeric(returns)  # 转换为普通向量
# 设置置信水平
alpha <- 0.95
# 构建ARX模型（滞后1阶）
# 使用普通向量而非xts对象
arx_model <- arx(returns_vector ~ 1 + lags(returns_vector, 1))
# 计算VaR和ES
risk_results[["gets"]] <- list(
VaR = VaR(arx_model, level = 1 - alpha),
ES = ES(arx_model, level = 1 - alpha)
)
# 加载必要的包
library(quantmod)
library(gets)
library(xts)
# 获取纳斯达克指数数据并计算收益率
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
returns <- diff(log(Cl(IXIC)))
returns <- as.vector(na.omit(returns))  # 强制转换为普通向量
# 设置置信水平
alpha <- 0.95
# 构建ARX模型（滞后1阶）
# 使用普通向量而非xts对象
arx_model <- arx(returns, mc=TRUE, ar=1)  # 直接使用向量格式
# 计算VaR和ES
risk_results <- list(
VaR = quantile(arx_model$residuals, probs=1-alpha),
ES = mean(arx_model$residuals[arx_model$residuals <= quantile(arx_model$residuals, probs=1-alpha)])
)
# 打印结果
cat("ARX模型风险度量结果:\n")
cat("VaR (", alpha*100, "%):", round(risk_results[["gets"]]$VaR*100, 2), "%\n")
cat("ES (", alpha*100, "%):", round(risk_results[["gets"]]$ES*100, 2), "%\n")
VaR = quantile(arx_model$residuals, probs=1-alpha),
ES = mean(arx_model$residuals[arx_model$residuals <= quantile(arx_model$residuals, probs=1-alpha)])
VaR = quantile(arx_model$residuals, probs=1-alpha)
ES = mean(arx_model$residuals[arx_model$residuals <= quantile(arx_model$residuals, probs=1-alpha)])
# 打印结果
cat("ARX模型风险度量结果:\n")
cat("VaR (", alpha*100, "%):", round(risk_results[["gets"]]$VaR*100, 2), "%\n")
cat("ES (", alpha*100, "%):", round(risk_results[["gets"]]$ES*100, 2), "%\n")
arx_model <- arx(returns, mc=TRUE, ar=1)  # 直接使用向量格式
# 计算VaR和ES
risk_results <- list(
VaR = quantile(arx_model$residuals, probs=1-alpha),
ES = mean(arx_model$residuals[arx_model$residuals <= quantile(arx_model$residuals, probs=1-alpha)])
)
risk_results
# 打印结果
cat("ARX模型风险度量结果:\n")
cat("VaR (", alpha*100, "%):", round(risk_results$VaR*100, 2), "%\n")
cat("ES (", alpha*100, "%):", round(risk_results$ES*100, 2), "%\n")
if (!require("MSGARCH")) install.packages("MSGARCH")
library(MSGARCH)
spec_msgarch <- CreateSpec()
fit_msgarch <- FitML(spec_msgarch, data = returns)
risk_msgarch <- Risk(fit_msgarch, n.ahead = 1, level = alpha)
risk_results[["MSGARCH"]] <- list(
VaR = as.numeric(risk_msgarch$VaR),
ES = as.numeric(risk_msgarch$ES)
)
# 加载必要的包
library(quantmod)
library(gets)
library(xts)
# 获取纳斯达克指数数据并计算收益率
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
returns <- diff(log(Cl(IXIC)))
returns <- as.vector(na.omit(returns))  # 强制转换为普通向量
# 设置置信水平
alpha <- 0.95
# 构建ARX模型（滞后1阶）
# 使用普通向量而非xts对象
arx_model <- arx(returns, mc=TRUE, ar=1)  # 直接使用向量格式
# 计算VaR和ES
risk_results[["gets"]] <- list(
VaR = quantile(arx_model$residuals, probs=1-alpha),
ES = mean(arx_model$residuals[arx_model$residuals <= quantile(arx_model$residuals, probs=1-alpha)])
)
# 打印结果
cat("ARX模型风险度量结果:\n")
cat("VaR (", alpha*100, "%):", round(risk_results[["gets"]]$VaR*100, 2), "%\n")
cat("ES (", alpha*100, "%):", round(risk_results[["gets"]]$ES*100, 2), "%\n")
if (!require("MSGARCH")) install.packages("MSGARCH")
library(MSGARCH)
spec_msgarch <- CreateSpec()
fit_msgarch <- FitML(spec_msgarch, data = returns)
risk_msgarch <- Risk(fit_msgarch, n.ahead = 1, level = alpha)
risk_results[["MSGARCH"]] <- list(
VaR = as.numeric(risk_msgarch$VaR),
ES = as.numeric(risk_msgarch$ES)
)
if (!require("VaRES")) install.packages("VaRES")
library(VaRES)
# 基于t分布（更适合厚尾数据）
risk_t <- VaRES::ES(returns, p = alpha, dist = "std")  # std表示学生t分布
risk_results[["VaRES"]] <- list(
VaR = VaRES::VaR(returns, p = alpha, dist = "std"),
ES = risk_t
)
?VaRES
risk_t <- VaRES::varT(returns)
risk_t
if (!require("VaRES")) install.packages("VaRES")
library(VaRES)
# 基于t分布（更适合厚尾数据）
risk_t <- VaRES::esT(returns)  # std表示学生t分布
risk_results[["VaRES"]] <- list(
VaR = VaRES::varT(returns),
ES = risk_t
)
risk_results
if (!require("VaRES")) install.packages("VaRES")
library(VaRES)
# 加载必要的包
library(quantmod)
# 获取纳斯达克指数数据并计算收益率
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
returns <- diff(log(Cl(IXIC)))
returns <- na.omit(returns)  # 强制转换为普通向量
# 基于t分布（更适合厚尾数据）
risk_t <- VaRES::esT(returns)  # std表示学生t分布
risk_results[["VaRES"]] <- list(
VaR = VaRES::varT(returns),
ES = risk_t
)
risk_t
VaR = VaRES::varT(returns)
VaR
returns
risk_t <- VaRES::esT(returns)
x=runif(10,min=0,max=1)
dT(x)
pT(x)
varT(x)
esT(x)
if (!require("VaRES")) install.packages("VaRES")
library(VaRES)
# 加载必要的包
library(quantmod)
# 获取纳斯达克指数数据并计算收益率
getSymbols("^IXIC", from = "2020-01-01", to = Sys.Date())
returns <- diff(log(Cl(IXIC)))
returns <- na.omit(returns)  # 强制转换为普通向量
# 基于t分布（更适合厚尾数据）
risk_t <- VaRES::esT(returns)  # std表示学生t分布
risk_results[["VaRES"]] <- list(
VaR = VaRES::varT(returns),
ES = risk_t
)
risk_results
View(risk_results)

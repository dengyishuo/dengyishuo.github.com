max_lat <- 40.05
# 创建五环边界框并确保其有效性
五环边界 <- st_sfc(
st_polygon(list(rbind(
c(min_lon, min_lat),
c(max_lon, min_lat),
c(max_lon, max_lat),
c(min_lon, max_lat),
c(min_lon, min_lat)
))),
crs = st_crs(beijing_map)
) %>% st_make_valid()
# 尝试不同的方法获取五环内区域
# 方法1：使用裁剪代替交集
beijing_5th_ring <- st_crop(beijing_map, 五环边界)
# 如果方法1仍然出错，尝试方法2：先过滤再裁剪
if (inherits(beijing_5th_ring, "sf") && nrow(beijing_5th_ring) == 0) {
# 先通过边界框快速过滤
bbox <- st_bbox(五环边界)
beijing_5th_ring <- beijing_map[bbox, , op = st_intersects]
# 再裁剪
beijing_5th_ring <- st_crop(beijing_5th_ring, 五环边界)
}
# 寺庙数据
temples <- data.frame(
name = c(
"雍和宫", "五塔寺", "西黄寺", "天宁寺", "智化寺",
"广化寺", "广济寺", "通教寺", "法源寺", "卧佛寺"
),
longitude = c(116.4070, 116.3197, 116.3936, 116.3213, 116.4350,
116.3647, 116.3710, 116.4243, 116.3913, 116.2731),
latitude = c(39.9486, 39.9592, 39.9685, 39.8987, 39.9197,
39.9463, 39.9213, 39.9417, 39.8947, 39.9992)
)
# 过滤并转换为sf对象
temples <- temples %>%
filter(longitude >= min_lon & longitude <= max_lon &
latitude >= min_lat & latitude <= max_lat)
temples_sf <- st_as_sf(temples, coords = c("longitude", "latitude"),
crs = st_crs(beijing_map))
# 绘制地图
ggplot() +
geom_sf(data = beijing_5th_ring, fill = "lightgray", color = "gray50") +
geom_sf(data = temples_sf, color = "red", size = 3) +
geom_sf_text(data = temples_sf, aes(label = name),
color = "darkred", size = 3, nudge_y = 0.01) +
ggtitle("北京五环内寺庙分布图") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
axis.text = element_text(size = 8)
) +
coord_sf(xlim = c(min_lon, max_lon), ylim = c(min_lat, max_lat))
rm(list=ls())
shiny::runApp('~/My-Shiny/Big3-3')
blogdown:::new_post_addin()
rm(list=ls())
getwd()
setwd(/Users/matrixspk)
setwd("/Users/matrixspk")
# 安装并加载所需包
if (!require("quantmod")) install.packages("quantmod")
if (!require("PerformanceAnalytics")) install.packages("PerformanceAnalytics")
if (!require("dplyr")) install.packages("dplyr")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("tidyr")) install.packages("tidyr")
library(quantmod)
library(PerformanceAnalytics)
library(dplyr)
library(ggplot2)
library(tidyr)
# ------------------------------------------------------------------------------
# 1. 数据获取：沪深300指数（000300.SS）日度数据
# ------------------------------------------------------------------------------
# 尝试从Yahoo Finance获取，失败则切换到ifeng数据源
tryCatch({
getSymbols("000300.SS", src = "yahoo",
from = "2005-01-01", to = "2025-11-13",  # 覆盖足够长周期
auto.assign = TRUE)
}, error = function(e) {
message("Yahoo数据源获取失败，尝试使用ifeng数据源...")
getSymbols("000300.SS", src = "ifeng",
from = "2005-01-01", to = "2025-11-13",
auto.assign = TRUE)
})
# 提取收盘价并计算日对数收益率（更适合复利计算）
hs300 <- `000300.SS`[, "000300.SS.Close"]  # 筛选收盘价
colnames(hs300) <- "Close"                  # 重命名列
hs300$Return <- Delt(hs300$Close, type = "log")  # 对数收益率
hs300 <- na.omit(hs300)                     # 去除缺失值
# ------------------------------------------------------------------------------
# 2. 定义滚动投资参数
# ------------------------------------------------------------------------------
cycles <- c(1, 2, 3, 5, 10)                 # 滚动周期（年）
cycle_days <- cycles * 252                   # 转换为交易日数（年=252个交易日）
max_cycle_days <- max(cycle_days)            # 最大周期（10年=2520天）
start_idx <- max_cycle_days + 1              # 共同起始索引（确保所有周期有数据）
start_date <- index(hs300)[start_idx]        # 共同起始日期
# ------------------------------------------------------------------------------
# 3. 计算不同周期的滚动累计收益率
# ------------------------------------------------------------------------------
# 初始化累计收益数据框
cumulative_returns <- data.frame(
Date = index(hs300)[start_idx:length(hs300)]
)
# 循环计算每个周期的滚动累计收益
for (i in seq_along(cycles)) {
cycle <- cycles[i]
days <- cycle_days[i]
# 滚动计算N天累计对数收益率（窗口右对齐）
roll_log_return <- rollapply(
hs300$Return,
width = days,
FUN = sum,
align = "right",
fill = NA
)
# 指数化转换为累计收益率（1元投资的总收益）
roll_return <- exp(roll_log_return) - 1
# 筛选共同时间区间的数据
roll_return_filtered <- roll_return[start_idx:length(roll_return)]
# 存入数据框
cumulative_returns[[paste0("Cycle_", cycle, "Y")]] <- roll_return_filtered
}
# 加载必要的包
library(quantmod)
library(PerformanceAnalytics)
library(tidyverse)
library(lubridate)
# 获取沪深300指数数据（从2005年开始）
getSymbols("000300.SS", from = "2005-01-01", src = "yahoo")
# 提取收盘价数据
hs300_prices <- Cl(`000300.SS`)
# 计算日收益率
hs300_returns <- dailyReturn(hs300_prices)
# 转换为数据框格式
returns_df <- data.frame(
date = index(hs300_returns),
return = as.numeric(hs300_returns)
)
# 定义计算滚动收益的函数
calculate_rolling_returns <- function(returns, years) {
# 转换为年化交易日数（约252天）
periods <- years * 252
# 计算滚动累计收益
rolling_cumreturns <- rollapply(returns,
width = periods,
FUN = function(x) prod(1 + x) - 1,
fill = NA,
align = "left")
# 计算年化收益率
rolling_annualized <- rollapply(returns,
width = periods,
FUN = function(x) {
total_return <- prod(1 + x) - 1
annualized_return <- (1 + total_return)^(1/years) - 1
return(annualized_return)
},
fill = NA,
align = "left")
return(list(cumulative = rolling_cumreturns,
annualized = rolling_annualized))
}
# 计算不同持有周期的滚动收益
holding_periods <- c(1, 2, 3, 5, 10)
results <- list()
for (period in holding_periods) {
cat(sprintf("计算 %d 年持有期滚动收益...\n", period))
results[[as.character(period)]] <- calculate_rolling_returns(returns_df$return, period)
}
# 创建结果数据框
create_results_df <- function(results, returns_df) {
result_list <- list()
for (period in names(results)) {
temp_df <- data.frame(
date = returns_df$date[1:length(results[[period]]$cumulative)],
holding_period = as.numeric(period),
cumulative_return = as.numeric(results[[period]]$cumulative),
annualized_return = as.numeric(results[[period]]$annualized)
)
result_list[[period]] <- na.omit(temp_df)
}
bind_rows(result_list)
}
# 生成最终结果
final_results <- create_results_df(results, returns_df)
# 查看结果摘要
cat("\n各持有期收益统计摘要:\n")
final_results %>%
group_by(holding_period) %>%
summarise(
observations = n(),
mean_cumulative = mean(cumulative_return, na.rm = TRUE),
median_cumulative = median(cumulative_return, na.rm = TRUE),
mean_annualized = mean(annualized_return, na.rm = TRUE),
median_annualized = median(annualized_return, na.rm = TRUE),
min_annualized = min(annualized_return, na.rm = TRUE),
max_annualized = max(annualized_return, na.rm = TRUE)
) %>%
print(n = Inf)
# 可视化结果
ggplot(final_results, aes(x = date, y = annualized_return, color = as.factor(holding_period))) +
geom_line(alpha = 0.7) +
labs(title = "沪深300指数不同持有期滚动年化收益率",
x = "日期",
y = "年化收益率",
color = "持有期(年)") +
theme_minimal() +
scale_y_continuous(labels = scales::percent)
# 绘制分布图
ggplot(final_results, aes(x = annualized_return, fill = as.factor(holding_period))) +
geom_density(alpha = 0.5) +
labs(title = "不同持有期年化收益率分布",
x = "年化收益率",
y = "密度",
fill = "持有期(年)") +
theme_minimal() +
scale_x_continuous(labels = scales::percent) +
facet_wrap(~holding_period, scales = "free_y")
# 查看最近一个滚动期的收益
cat("\n最近一个滚动期收益:\n")
final_results %>%
group_by(holding_period) %>%
filter(date == max(date)) %>%
select(holding_period, date, cumulative_return, annualized_return) %>%
print(n = Inf)
# 可视化结果
ggplot(final_results, aes(x = date, y = annualized_return, color = as.factor(holding_period))) +
geom_line(alpha = 0.7) +
labs(title = "沪深300指数不同持有期滚动年化收益率",
x = "日期",
y = "年化收益率",
color = "持有期(年)") +
theme_minimal() +
scale_y_continuous(labels = scales::percent)
getSymbols("000300.SS", from = "2005-01-01", src = "yahoo")
View(`000300.SS`)
library(shiny)
library(quantmod)
library(PerformanceAnalytics)
library(tidyverse)
library(lubridate)
library(plotly)
library(DT)
# UI定义
ui <- fluidPage(
titlePanel("股票滚动收益分析器"),
sidebarLayout(
sidebarPanel(
width = 3,
textInput("stock_code", "股票代码:", value = "000300.SS"),
textInput("stock_name", "股票名称:", value = "沪深300指数"),
dateInput("start_date", "开始日期:", value = "2005-01-01"),
numericInput("trading_days", "年交易日数:", value = 252, min = 200, max = 365),
tags$hr(),
h4("持有周期设置"),
checkboxGroupInput("holding_periods", "选择持有周期(年):",
choices = c(1, 2, 3, 5, 10),
selected = c(1, 3, 5, 10)),
tags$hr(),
actionButton("calculate", "计算收益", class = "btn-primary"),
tags$hr(),
downloadButton("download_data", "下载数据")
),
mainPanel(
width = 9,
tabsetPanel(
tabPanel("收益图表",
fluidRow(
column(6, plotlyOutput("cumulative_plot")),
column(6, plotlyOutput("annualized_plot"))
),
fluidRow(
column(6, plotlyOutput("distribution_plot")),
column(6, plotlyOutput("box_plot"))
)
),
tabPanel("数据表格",
DTOutput("results_table")
),
tabPanel("统计摘要",
DTOutput("summary_table")
),
tabPanel("最新收益",
DTOutput("latest_returns")
)
# 服务器逻辑
server <- function(input, output, session) {
# 反应式数据获取
stock_data <- eventReactive(input$calculate, {
req(input$stock_code)
withProgress(message = '正在获取股票数据...', value = 0.3, {
tryCatch({
getSymbols(input$stock_code,
from = input$start_date,
auto.assign = FALSE)
}, error = function(e) {
showNotification("获取数据失败，请检查股票代码是否正确", type = "error")
return(NULL)
})
# 计算滚动收益
calculated_returns <- reactive({
req(stock_data())
withProgress(message = '计算滚动收益...', value = 0.6, {
# 提取收盘价数据
prices <- Cl(stock_data())
# 计算日收益率
returns <- dailyReturn(prices)
# 转换为数据框格式
returns_df <- data.frame(
date = index(returns),
return = as.numeric(returns)
)
# 定义计算滚动收益的函数
calculate_rolling_returns <- function(returns, years, trading_days) {
periods <- years * trading_days
# 计算滚动累计收益
rolling_cumreturns <- rollapply(returns,
width = periods,
FUN = function(x) prod(1 + x) - 1,
fill = NA,
align = "left")
# 计算年化收益率
rolling_annualized <- rollapply(returns,
width = periods,
FUN = function(x) {
total_return <- prod(1 + x) - 1
annualized_return <- (1 + total_return)^(1/years) - 1
return(annualized_return)
},
fill = NA,
align = "left")
return(list(cumulative = rolling_cumreturns,
annualized = rolling_annualized))
}
# 计算不同持有周期的滚动收益
results <- list()
periods <- as.numeric(input$holding_periods)
for (period in periods) {
results[[as.character(period)]] <- calculate_rolling_returns(
returns_df$return, period, input$trading_days)
}
# 创建结果数据框
create_results_df <- function(results, returns_df) {
result_list <- list()
for (period in names(results)) {
temp_df <- data.frame(
date = returns_df$date[1:length(results[[period]]$cumulative)],
holding_period = as.numeric(period),
cumulative_return = as.numeric(results[[period]]$cumulative),
annualized_return = as.numeric(results[[period]]$annualized)
)
result_list[[period]] <- na.omit(temp_df)
}
bind_rows(result_list)
}
final_results <- create_results_df(results, returns_df)
return(final_results)
})
# 累计收益图表
output$cumulative_plot <- renderPlotly({
req(calculated_returns())
df <- calculated_returns()
p <- ggplot(df, aes(x = date, y = cumulative_return,
color = as.factor(holding_period),
group = holding_period)) +
geom_line(alpha = 0.8) +
labs(title = paste(input$stock_name, "- 不同持有期累计收益率"),
x = "日期",
y = "累计收益率",
color = "持有期(年)") +
theme_minimal() +
scale_y_continuous(labels = scales::percent) +
theme(legend.position = "bottom")
ggplotly(p) %>% layout(legend = list(orientation = "h", y = -0.2))
})
# 年化收益图表
output$annualized_plot <- renderPlotly({
req(calculated_returns())
df <- calculated_returns()
p <- ggplot(df, aes(x = date, y = annualized_return,
color = as.factor(holding_period),
group = holding_period)) +
geom_line(alpha = 0.8) +
labs(title = paste(input$stock_name, "- 不同持有期年化收益率"),
x = "日期",
y = "年化收益率",
color = "持有期(年)") +
theme_minimal() +
scale_y_continuous(labels = scales::percent) +
theme(legend.position = "bottom")
ggplotly(p) %>% layout(legend = list(orientation = "h", y = -0.2))
})
# 收益分布图
output$distribution_plot <- renderPlotly({
req(calculated_returns())
df <- calculated_returns()
p <- ggplot(df, aes(x = annualized_return, fill = as.factor(holding_period))) +
geom_density(alpha = 0.6) +
labs(title = paste(input$stock_name, "- 年化收益率分布"),
x = "年化收益率",
y = "密度",
fill = "持有期(年)") +
theme_minimal() +
scale_x_continuous(labels = scales::percent) +
facet_wrap(~holding_period, scales = "free_y") +
theme(strip.text = element_text(face = "bold"))
ggplotly(p)
})
# 箱线图
output$box_plot <- renderPlotly({
req(calculated_returns())
df <- calculated_returns()
p <- ggplot(df, aes(x = as.factor(holding_period), y = annualized_return,
fill = as.factor(holding_period))) +
geom_boxplot(alpha = 0.7) +
labs(title = paste(input$stock_name, "- 年化收益率箱线图"),
x = "持有期(年)",
y = "年化收益率",
fill = "持有期(年)") +
theme_minimal() +
scale_y_continuous(labels = scales::percent)
ggplotly(p)
})
# 数据表格
output$results_table <- renderDT({
req(calculated_returns())
df <- calculated_returns() %>%
mutate(
cumulative_return = scales::percent(cumulative_return, accuracy = 0.01),
annualized_return = scales::percent(annualized_return, accuracy = 0.01),
date = as.character(date)
)
datatable(df,
options = list(
pageLength = 10,
scrollX = TRUE,
autoWidth = TRUE
),
caption = paste(input$stock_name, "- 滚动收益数据")
) %>% formatStyle(
'annualized_return',
backgroundColor = styleInterval(0, c('#FFE6E6', '#E6FFE6'))
)
})
# 统计摘要表格
output$summary_table <- renderDT({
req(calculated_returns())
summary_df <- calculated_returns() %>%
group_by(holding_period) %>%
summarise(
observations = n(),
mean_cumulative = mean(cumulative_return, na.rm = TRUE),
median_cumulative = median(cumulative_return, na.rm = TRUE),
mean_annualized = mean(annualized_return, na.rm = TRUE),
median_annualized = median(annualized_return, na.rm = TRUE),
min_annualized = min(annualized_return, na.rm = TRUE),
max_annualized = max(annualized_return, na.rm = TRUE),
sd_annualized = sd(annualized_return, na.rm = TRUE)
) %>%
mutate(
mean_cumulative = scales::percent(mean_cumulative, accuracy = 0.01),
median_cumulative = scales::percent(median_cumulative, accuracy = 0.01),
mean_annualized = scales::percent(mean_annualized, accuracy = 0.01),
median_annualized = scales::percent(median_annualized, accuracy = 0.01),
min_annualized = scales::percent(min_annualized, accuracy = 0.01),
max_annualized = scales::percent(max_annualized, accuracy = 0.01),
sd_annualized = scales::percent(sd_annualized, accuracy = 0.01)
)
datatable(summary_df,
options = list(
dom = 't',
scrollX = TRUE
),
caption = paste(input$stock_name, "- 收益统计摘要")
)
})
# 最新收益表格
output$latest_returns <- renderDT({
req(calculated_returns())
latest_df <- calculated_returns() %>%
group_by(holding_period) %>%
filter(date == max(date)) %>%
select(holding_period, date, cumulative_return, annualized_return) %>%
mutate(
cumulative_return = scales::percent(cumulative_return, accuracy = 0.01),
annualized_return = scales::percent(annualized_return, accuracy = 0.01),
date = as.character(date)
)
datatable(latest_df,
options = list(
dom = 't',
scrollX = TRUE
),
caption = paste(input$stock_name, "- 最新滚动期收益")
) %>% formatStyle(
'annualized_return',
backgroundColor = styleInterval(0, c('#FFE6E6', '#E6FFE6'))
)
})
# 数据下载
output$download_data <- downloadHandler(
filename = function() {
paste(input$stock_name, "_滚动收益数据_", Sys.Date(), ".csv", sep = "")
},
content = function(file) {
write.csv(calculated_returns(), file, row.names = FALSE)
}
)
}
# 运行Shiny应用
shinyApp(ui = ui, server = server)

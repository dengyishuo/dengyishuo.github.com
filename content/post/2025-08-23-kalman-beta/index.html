---
title: 使用卡尔曼滤波计算个股的动态贝塔
author: DengYishuo
date: '2025-08-23'
slug: kalman-beta
categories:
  - investment
tags:
  - beta
  - r
---



<div id="引言" class="section level1">
<h1>引言</h1>
<p>在金融领域，贝塔（β）系数是资本资产定价模型（CAPM）中的核心参数，用于衡量单个资产或证券组合相对于整个市场（通常以市场指数代表）的系统性风险或波动性。具体而言，贝塔反映了市场收益率变动一个单位时，个体资产收益率的预期变动幅度。准确估计贝塔对于投资组合管理、风险控制、资产定价以及绩效评估都具有重要意义。例如，投资者可通过贝值判断资产的风险属性，进行合理的资产配置；基金经理也可依据贝塔调整投资组合的市场暴露程度。</p>
<p>传统的贝塔估计方法主要依赖于最小二乘（OLS）回归。通过在给定时间窗口（如1年、3年或5年）内对资产收益率与市场收益率进行线性回归，所得斜率系数即为贝塔估计值。此外，为降低短期波动带来的误差，也常采用滚动窗口回归或调整贝塔（Adjusted Beta）等方法。</p>
<p>然而，这些传统方法存在明显不足。首先，它们隐含假设贝塔在估计期间内是固定不变的，但事实上，受公司资本结构、经营策略、行业竞争及宏观经济环境等因素影响，资产的系统性风险可能随时间变化，即贝塔具有时变性。其次，滚动窗口回归中窗口长度的选择缺乏统一标准，较短窗口对噪声敏感，较长窗口则可能无法及时捕捉最新变化。再者，这些方法无法提供实时更新的贝塔估计，难以满足动态风险管理的需求。</p>
<p>为克服上述不足，本研究引入卡尔曼滤波（Kalman Filter）方法进行时变贝塔的估计。卡尔曼滤波是一种递归状态估计算法，能够从带有噪声的观测数据中最优地估计动态系统的内部状态。其核心优势在于能够实时更新状态估计，并通过建模状态变量的动态演化过程（如随机游走）来捕捉参数的时变特性。将卡尔曼滤波应用于贝塔估计，不仅可以得到随时间平滑变化的贝塔序列，还能通过状态空间模型灵活描述贝塔的动态行为，从而提供更准确、适应性的风险度量。</p>
</div>
<div id="卡尔曼滤波原理及其在计算贝塔中的应用" class="section level1">
<h1>卡尔曼滤波原理及其在计算贝塔中的应用</h1>
<p>卡尔曼滤波是一种最优递归数据处理算法，用于从一系列存在噪声的观测数据中估计动态系统的内部状态。其基本思想是通过结合系统模型的预测（先验估计）和当前观测值的更新，递归地得到状态的最优估计（后验估计）。该算法主要包含两个步骤：预测（时间更新）和更新（测量更新）。</p>
<div id="基本原理" class="section level2">
<h2>基本原理</h2>
<ol style="list-style-type: decimal">
<li><strong>状态空间模型</strong><br />
卡尔曼滤波建立在状态空间模型之上，包括状态方程和观测方程：
<ul>
<li>状态方程（系统模型）：描述状态向量如何随时间演化<br />
<span class="math display">\[x_t = F_t x_{t-1} + B_t u_t + w_t\]</span><br />
其中，<span class="math inline">\(x_t\)</span>为<span class="math inline">\(t\)</span>时刻的状态向量，<span class="math inline">\(F_t\)</span>为状态转移矩阵，<span class="math inline">\(u_t\)</span>为控制输入向量（可选），<span class="math inline">\(B_t\)</span>为控制输入矩阵，<span class="math inline">\(w_t \sim N(0, Q_t)\)</span>为过程噪声。<br />
</li>
<li>观测方程（测量模型）：描述观测值与状态向量的关系<br />
<span class="math display">\[z_t = H_t x_t + v_t\]</span><br />
其中，<span class="math inline">\(z_t\)</span>为<span class="math inline">\(t\)</span>时刻的观测向量，<span class="math inline">\(H_t\)</span>为观测矩阵，<span class="math inline">\(v_t \sim N(0, R_t)\)</span>为观测噪声。</li>
</ul></li>
<li><strong>算法步骤</strong>
<ul>
<li><strong>预测步骤</strong>：<br />
先验状态估计：<br />
<span class="math display">\[\hat{x}_t^{-} = F_t \hat{x}_{t-1} + B_t u_t\]</span><br />
先验误差协方差：<br />
<span class="math display">\[P_t^{-} = F_t P_{t-1} F_t^T + Q_t\]</span><br />
</li>
<li><strong>更新步骤</strong>：<br />
卡尔曼增益：<br />
<span class="math display">\[K_t = P_t^{-} H_t^T (H_t P_t^{-} H_t^T + R_t)^{-1}\]</span><br />
后验状态估计：<br />
<span class="math display">\[\hat{x}_t = \hat{x}_t^{-} + K_t (z_t - H_t \hat{x}_t^{-})\]</span><br />
后验误差协方差：<br />
<span class="math display">\[P_t = (I - K_t H_t) P_t^{-}\]</span></li>
</ul></li>
</ol>
</div>
<div id="在计算贝塔时的应用" class="section level2">
<h2>在计算贝塔时的应用</h2>
<p>在时变贝塔估计中，我们将CAPM模型置于状态空间框架下。假设在时刻<span class="math inline">\(t\)</span>，资产超额收益<span class="math inline">\(r_{a,t}\)</span>与市场超额收益<span class="math inline">\(r_{m,t}\)</span>满足：<br />
<span class="math display">\[r_{a,t} = \alpha_t + \beta_t r_{m,t} + \epsilon_t\]</span><br />
其中，<span class="math inline">\(\alpha_t\)</span>和<span class="math inline">\(\beta_t\)</span>为时变参数，<span class="math inline">\(\epsilon_t\)</span>为观测噪声。</p>
<p>定义状态向量为<span class="math inline">\(x_t = [\alpha_t, \beta_t]^T\)</span>，则状态空间模型可表示为：<br />
- 状态方程（假设参数遵循随机游走）：<br />
<span class="math display">\[x_t = x_{t-1} + w_t\]</span><br />
其中，<span class="math inline">\(w_t\)</span>为过程噪声，协方差矩阵为<span class="math inline">\(Q\)</span>。<br />
- 观测方程：<br />
<span class="math display">\[z_t = H_t x_t + v_t\]</span><br />
其中，<span class="math inline">\(z_t = r_{a,t}\)</span>，<span class="math inline">\(H_t = [1, r_{m,t}]\)</span>，<span class="math inline">\(v_t = \epsilon_t\)</span>为观测噪声，方差为<span class="math inline">\(R\)</span>。</p>
<p>通过卡尔曼滤波递归处理数据，可得到状态向量（即<span class="math inline">\(\alpha_t\)</span>和<span class="math inline">\(\beta_t\)</span>）的最优估计。滤波结果（Filtered）基于当前及过去信息，适用于实时估计；平滑结果（Smoothed）利用全部样本信息，适用于事后分析。</p>
</div>
</div>
<div id="r代码实例" class="section level1">
<h1>R代码实例</h1>
<pre class="r"><code># 安装必要的包（如果尚未安装）
if (!require(&quot;quantmod&quot;)) install.packages(&quot;quantmod&quot;)  # 用于获取数据
if (!require(&quot;dlm&quot;)) install.packages(&quot;dlm&quot;)            # 用于卡尔曼滤波
if (!require(&quot;ggplot2&quot;)) install.packages(&quot;ggplot2&quot;)    # 用于绘图
if (!require(&quot;reshape2&quot;)) install.packages(&quot;reshape2&quot;)  # 用于数据重塑

# 加载包
library(quantmod)
library(dlm)
library(ggplot2)
library(reshape2)

# 设置时间范围
start_date &lt;- as.Date(&quot;2020-01-01&quot;)
end_date &lt;- Sys.Date() # 使用当前日期

# 下载AAPL和SPY的日收盘价数据
getSymbols(&quot;AAPL&quot;, src = &quot;yahoo&quot;, from = start_date, to = end_date)</code></pre>
<pre><code>## [1] &quot;AAPL&quot;</code></pre>
<pre class="r"><code>getSymbols(&quot;SPY&quot;, src = &quot;yahoo&quot;, from = start_date, to = end_date)</code></pre>
<pre><code>## [1] &quot;SPY&quot;</code></pre>
<pre class="r"><code># 提取收盘价并合并数据
aapl_close &lt;- Cl(AAPL)
spy_close &lt;- Cl(SPY)
merged_data &lt;- merge(aapl_close, spy_close)
colnames(merged_data) &lt;- c(&quot;AAPL&quot;, &quot;SPY&quot;)

# 计算日对数收益率
returns &lt;- na.omit(data.frame(
  Date = index(merged_data),
  AAPL_Return = as.numeric(ROC(merged_data$AAPL)),
  SPY_Return = as.numeric(ROC(merged_data$SPY))
))

# 使用dlm构建卡尔曼滤波模型
buildCapm &lt;- function(parm) {
  dlmMod &lt;- dlm(
    FF = matrix(c(1, 0), nrow=1),
    V = exp(parm[1]),
    GG = diag(2),
    W = diag(exp(parm[2:3])),
    m0 = c(0, 1),
    C0 = diag(2)
  )
  dlmMod$JFF &lt;- matrix(c(0, 1), nrow=1)
  dlmMod$X &lt;- returns$SPY_Return
  return(dlmMod)
}

# 初始参数猜测（取对数后的方差）
init_parm &lt;- c(log(0.01), log(0.0001), log(0.0001))

# 使用dlmMLE优化参数
mle_result &lt;- dlmMLE(
  y = returns$AAPL_Return,
  parm = init_parm,
  build = buildCapm
)

# 检查优化是否成功
if (mle_result$convergence != 0) {
  warning(&quot;参数优化可能未完全收敛。&quot;)
}

# 用优化后的参数构建最终的dlm模型
final_model &lt;- buildCapm(mle_result$par)

# 运行卡尔曼滤波和平滑
filtered_result &lt;- dlmFilter(returns$AAPL_Return, final_model)
smoothed_result &lt;- dlmSmooth(filtered_result)

# 提取平滑后的状态估计
alpha_smoothed &lt;- smoothed_result$s[-1, 1]
beta_smoothed &lt;- smoothed_result$s[-1, 2]

# 提取滤波后的状态估计
alpha_filtered &lt;- filtered_result$m[-1, 1]
beta_filtered &lt;- filtered_result$m[-1, 2]

# 将结果添加到数据框中
returns$Alpha_Smoothed &lt;- alpha_smoothed
returns$Beta_Smoothed &lt;- beta_smoothed
returns$Alpha_Filtered &lt;- alpha_filtered
returns$Beta_Filtered &lt;- beta_filtered

# 绘制时变贝塔系数
ggplot(returns, aes(x = Date)) +
  geom_line(aes(y = Beta_Smoothed, color = &quot;Smoothed β&quot;), linewidth = 0.8) +
  geom_line(aes(y = Beta_Filtered, color = &quot;Filtered β&quot;), linewidth = 0.5, linetype = &quot;dashed&quot;, alpha = 0.7) +
  geom_hline(yintercept = 1, linetype = &quot;dotted&quot;, color = &quot;black&quot;) +
  labs(title = &quot;AAPL vs SPY: Dynamic Beta Coefficient (Kalman Filter)&quot;,
       x = &quot;Date&quot;,
       y = &quot;Beta Value&quot;,
       color = &quot;Estimation Type&quot;) +
  theme_bw() +
  scale_color_manual(values = c(&quot;Smoothed β&quot; = &quot;darkgreen&quot;, &quot;Filtered β&quot; = &quot;darkred&quot;))</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
<pre class="r"><code># 绘制时变阿尔法系数
ggplot(returns, aes(x = Date)) +
  geom_line(aes(y = Alpha_Smoothed, color = &quot;Smoothed α&quot;), linewidth = 0.8) +
  geom_hline(yintercept = 0, linetype = &quot;dotted&quot;, color = &quot;black&quot;) +
  labs(title = &quot;AAPL vs SPY: Dynamic Alpha Coefficient (Kalman Filter)&quot;,
       x = &quot;Date&quot;,
       y = &quot;Alpha Value&quot;,
       color = &quot;Estimation Type&quot;) +
  theme_bw() +
  scale_color_manual(values = c(&quot;Smoothed α&quot; = &quot;darkgreen&quot;))</code></pre>
<p><img src="{{< blogdown/postref >}}index_files/figure-html/unnamed-chunk-1-2.png" width="672" /></p>
</div>
